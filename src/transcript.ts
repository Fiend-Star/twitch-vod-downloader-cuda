import { Database } from "https://deno.land/x/sqlite3@0.12.0/mod.ts";
import { exec, getDataPath } from "./utils.ts";
import { Video, WhisperOutput } from "./types.ts";
import { insertTranscript, deleteTranscriptByVideoId } from "./db/helpers.ts";
import { readJsonFile } from "./utils.ts";
import { join } from "https://deno.land/std@0.208.0/path/mod.ts";
import { ZodError } from "https://deno.land/x/zod@v3.22.4/mod.ts";

async function generateTranscript(db: Database, video: Video) {
  console.log(`üéôÔ∏è Generating transcript for video: ${video.id}`);

  const audioDir = getDataPath("audio");
  const transcriptsDir = getDataPath("transcripts");

  const audioFile = join(audioDir, `audio_${video.id}.wav`);
  const jsonFile = join(transcriptsDir, `transcript_${video.id}.json`);

  const maxAttempts = 3;
  const retryDelay = 5_000; 

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      // Convert the video file to audio.
      await exec(["ffmpeg", "-i", video.file_path, "-vn", "-acodec", "pcm_s16le", "-ar", "16000", "-ac", "1", audioFile]);

      // Run Whisper to generate the transcript. 
      // Note: This will output a file like `audio_${video.id}.json` inside transcriptsDir.
      await exec(["whisper", audioFile, "--model", "small", "--output_format", "json", "--output_dir", transcriptsDir]);

      // Rename the auto-generated file to our expected naming convention.
      const autoGeneratedFile = join(transcriptsDir, `audio_${video.id}.json`);
      await Deno.rename(autoGeneratedFile, jsonFile);

      // Read and parse the transcript.
      const rawData = await readJsonFile(jsonFile);

      console.log('Raw input:', rawData);
      console.log('Input type:', typeof rawData);
      console.log('Is array:', Array.isArray(rawData));

      const transcriptData = WhisperOutput.parse(rawData);

      insertTranscript(db, {
        id: crypto.randomUUID(),
        video_id: video.id,
        content: transcriptData.text,
        segments: JSON.stringify(transcriptData.segments),
        created_at: new Date().toISOString()
      });

      console.log(`‚úÖ Transcript generated and saved for video: ${video.id}`);
      return; 

    } catch (error) {
      console.error(`Attempt ${attempt} failed for video ${video.id}:`, error);

      if (error instanceof ZodError) {
          console.error("‚ùå Fatal ZodError: Data structure mismatch.  Deleting database entries and aborting.");
          try {
            await deleteTranscriptByVideoId(db, video.id);
            console.log(`Deleted transcript entries for video ID: ${video.id}`);
          } catch (dbError) {
            console.error("Error deleting transcript entries:", dbError);
          }
          return; // Abort after a ZodError
      }

      if (attempt < maxAttempts) {
        console.log(`Retrying in ${retryDelay / 1000} seconds...`);
        await new Promise(resolve => setTimeout(resolve, retryDelay));
      } else {
        console.error(`‚ùå Failed to generate transcript after ${maxAttempts} attempts for video ${video.id}.`);
      }
    }
  }
}

export { generateTranscript };
